"""Tests for Greptile parser.

This module tests the GreptileParser implementation, verifying:
- Author and body detection patterns (can_parse)
- Actionable comment count patterns
- Review summary detection
- Correct priority and requires_investigation values
"""

import pytest

from goodtogo.core.models import CommentClassification, Priority, ReviewerType
from goodtogo.parsers.greptile import GreptileParser


class TestGreptileParserCanParse:
    """Tests for GreptileParser.can_parse() method."""

    @pytest.fixture
    def parser(self) -> GreptileParser:
        """Create a GreptileParser instance."""
        return GreptileParser()

    def test_can_parse_by_author_exact_match(self, parser: GreptileParser) -> None:
        """Test detection by exact author match."""
        assert parser.can_parse("greptile[bot]", "") is True

    def test_can_parse_by_author_case_insensitive(self, parser: GreptileParser) -> None:
        """Test that author matching is case-insensitive."""
        assert parser.can_parse("Greptile[bot]", "") is True
        assert parser.can_parse("GREPTILE[BOT]", "") is True

    def test_can_parse_by_body_greptile_link(self, parser: GreptileParser) -> None:
        """Test detection by greptile.com link in body."""
        body = "Review powered by https://greptile.com"
        assert parser.can_parse("other-user", body) is True

    def test_can_parse_by_body_greptile_name(self, parser: GreptileParser) -> None:
        """Test detection by Greptile name in body."""
        body = "This review was generated by Greptile"
        assert parser.can_parse("other-user", body) is True

    def test_can_parse_by_body_case_insensitive(self, parser: GreptileParser) -> None:
        """Test that body signature detection is case-insensitive."""
        assert parser.can_parse("other", "Check out GREPTILE.COM") is True
        assert parser.can_parse("other", "powered by greptile") is True

    def test_can_parse_non_matching_author(self, parser: GreptileParser) -> None:
        """Test that non-matching authors are rejected."""
        assert parser.can_parse("random-user", "") is False
        assert parser.can_parse("github-bot", "") is False
        assert parser.can_parse("", "") is False

    def test_can_parse_non_matching_body(self, parser: GreptileParser) -> None:
        """Test that non-matching bodies are rejected."""
        assert parser.can_parse("random-user", "Regular comment body") is False
        assert parser.can_parse("random-user", "Some other review tool") is False


class TestGreptileParserReviewerType:
    """Tests for GreptileParser.reviewer_type property."""

    def test_reviewer_type_returns_greptile(self) -> None:
        """Test that reviewer_type returns GREPTILE."""
        parser = GreptileParser()
        assert parser.reviewer_type == ReviewerType.GREPTILE


class TestGreptileParserActionableCount:
    """Tests for actionable comment count pattern detection."""

    @pytest.fixture
    def parser(self) -> GreptileParser:
        """Create a GreptileParser instance."""
        return GreptileParser()

    def test_parse_zero_actionable_comments(self, parser: GreptileParser) -> None:
        """Test zero actionable comments results in NON_ACTIONABLE."""
        body = "Actionable comments posted: 0"
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_parse_one_actionable_comment(self, parser: GreptileParser) -> None:
        """Test one actionable comment results in ACTIONABLE."""
        body = "Actionable comments posted: 1"
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR
        assert requires_investigation is False

    def test_parse_multiple_actionable_comments(self, parser: GreptileParser) -> None:
        """Test multiple actionable comments results in ACTIONABLE."""
        body = "Actionable comments posted: 5"
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR
        assert requires_investigation is False

    def test_parse_large_actionable_count(self, parser: GreptileParser) -> None:
        """Test large actionable comment count."""
        body = "Actionable comments posted: 100"
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR
        assert requires_investigation is False

    def test_parse_actionable_count_case_insensitive(self, parser: GreptileParser) -> None:
        """Test actionable count pattern is case-insensitive."""
        body = "ACTIONABLE COMMENTS POSTED: 3"
        comment = {"body": body}
        classification, priority, _ = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE

    def test_parse_actionable_count_with_whitespace(self, parser: GreptileParser) -> None:
        """Test actionable count with extra whitespace."""
        body = "Actionable comments posted:    10"
        comment = {"body": body}
        classification, priority, _ = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE

    def test_parse_actionable_count_in_larger_body(self, parser: GreptileParser) -> None:
        """Test actionable count pattern embedded in larger body."""
        body = """
        ## Greptile Review Summary

        This PR looks good overall.

        Actionable comments posted: 2

        Please address the comments above before merging.
        """
        comment = {"body": body}
        classification, priority, _ = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR


class TestGreptileParserReviewSummary:
    """Tests for review summary detection."""

    @pytest.fixture
    def parser(self) -> GreptileParser:
        """Create a GreptileParser instance."""
        return GreptileParser()

    def test_parse_summary_header(self, parser: GreptileParser) -> None:
        """Test detection of Summary header."""
        body = "# Summary\n\nThis PR adds a new feature."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_parse_review_summary_header(self, parser: GreptileParser) -> None:
        """Test detection of Review Summary header."""
        body = "## Review Summary\n\nNo issues found."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_parse_pr_summary_header(self, parser: GreptileParser) -> None:
        """Test detection of PR Summary header."""
        body = "### PR Summary\n\nThis PR refactors the parser module."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_parse_reviewed_pr_phrase(self, parser: GreptileParser) -> None:
        """Test detection of 'reviewed this PR' phrase."""
        body = "I reviewed this PR and found no issues."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_parse_analyzed_pull_request(self, parser: GreptileParser) -> None:
        """Test detection of 'analyzed pull request' phrase."""
        body = "Greptile analyzed this pull request and found 0 issues."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_inline_comment_with_review_summary_is_non_actionable(
        self, parser: GreptileParser
    ) -> None:
        """Test inline comment with review summary content is NON_ACTIONABLE.

        Even inline comments (with path set) that contain review summary
        content should be NON_ACTIONABLE - this tests the body-level check.
        """
        body = "# Summary\n\nThis summarizes the review findings."
        comment = {"body": body, "path": "src/file.py", "line": 42}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert requires_investigation is False


class TestGreptileParserAmbiguous:
    """Tests for ambiguous comment handling."""

    @pytest.fixture
    def parser(self) -> GreptileParser:
        """Create a GreptileParser instance."""
        return GreptileParser()

    def test_parse_empty_body(self, parser: GreptileParser) -> None:
        """Test empty body results in AMBIGUOUS."""
        comment = {"body": ""}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True

    def test_parse_missing_body(self, parser: GreptileParser) -> None:
        """Test missing body key results in AMBIGUOUS."""
        comment = {}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True

    def test_parse_unrecognized_pattern(self, parser: GreptileParser) -> None:
        """Test unrecognized body pattern results in AMBIGUOUS."""
        comment = {"body": "Consider adding error handling here."}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True


class TestGreptileParserEdgeCases:
    """Tests for edge cases and special scenarios."""

    @pytest.fixture
    def parser(self) -> GreptileParser:
        """Create a GreptileParser instance."""
        return GreptileParser()

    def test_actionable_count_takes_precedence_over_summary(self, parser: GreptileParser) -> None:
        """Test that actionable count takes precedence over review summary."""
        body = """
        # Summary

        This PR looks good.

        Actionable comments posted: 3
        """
        comment = {"body": body}
        classification, priority, _ = parser.parse(comment)

        # Actionable count should be found first
        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR

    def test_zero_actionable_with_summary(self, parser: GreptileParser) -> None:
        """Test zero actionable comments with summary."""
        body = """
        # Summary

        No issues found.

        Actionable comments posted: 0
        """
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        # Zero actionable should result in NON_ACTIONABLE
        assert classification == CommentClassification.NON_ACTIONABLE

    def test_parse_body_with_only_whitespace(self, parser: GreptileParser) -> None:
        """Test body with only whitespace results in AMBIGUOUS."""
        comment = {"body": "   \n\t\n   "}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert requires_investigation is True


class TestGreptileParserSeverityMarkers:
    """Tests for Greptile severity marker detection."""

    @pytest.fixture
    def parser(self) -> GreptileParser:
        """Create a GreptileParser instance."""
        return GreptileParser()

    def test_parse_security_marker_critical(self, parser: GreptileParser) -> None:
        """Test **security:** marker is classified as ACTIONABLE CRITICAL."""
        body = "**security:** This exposes sensitive data."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.CRITICAL
        assert requires_investigation is False

    def test_parse_bug_marker_major(self, parser: GreptileParser) -> None:
        """Test **bug:** marker is classified as ACTIONABLE MAJOR."""
        body = "**bug:** This causes an exception."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MAJOR
        assert requires_investigation is False

    def test_parse_logic_marker_minor(self, parser: GreptileParser) -> None:
        """Test **logic:** marker is classified as ACTIONABLE MINOR."""
        body = "**logic:** This filter is unnecessary."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR
        assert requires_investigation is False

    def test_parse_style_marker_trivial(self, parser: GreptileParser) -> None:
        """Test **style:** marker is NON_ACTIONABLE TRIVIAL."""
        body = "**style:** Use snake_case."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.TRIVIAL
        assert requires_investigation is False

    def test_severity_marker_no_match(self, parser: GreptileParser) -> None:
        """Test _check_severity_markers returns None when no pattern matches."""
        result = parser._check_severity_markers("No severity marker here.")
        assert result is None


class TestGreptileParserPRLevelSummaryComments:
    """Tests for PR-level summary comment detection.

    PR-level summary comments from Greptile contain overview information and
    should be classified as NON_ACTIONABLE because the actual actionable items
    are in inline comments.
    """

    @pytest.fixture
    def parser(self) -> GreptileParser:
        """Create a GreptileParser instance."""
        return GreptileParser()

    def test_pr_summary_with_greptile_header(self, parser: GreptileParser) -> None:
        """Test PR-level summary with Greptile HTML header is NON_ACTIONABLE."""
        body = """<h3>Greptile Summary</h3>

This PR adds feature X.

**3 files reviewed**

Edit Code Review Agent Settings
"""
        comment = {"body": body, "path": None, "line": None}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert requires_investigation is False

    def test_pr_summary_with_files_reviewed(self, parser: GreptileParser) -> None:
        """Test PR-level summary with 'files reviewed' pattern is NON_ACTIONABLE."""
        body = """## Review Summary

5 files reviewed, no critical issues found.

Powered by Greptile
"""
        comment = {"body": body, "path": None, "line": None}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert requires_investigation is False

    def test_pr_summary_with_edit_settings_link(self, parser: GreptileParser) -> None:
        """Test PR-level summary with 'Edit Code Review Agent Settings' is NON_ACTIONABLE."""
        body = """Review complete.

Edit Code Review Agent Settings
"""
        comment = {"body": body, "path": None, "line": None}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert requires_investigation is False

    def test_pr_summary_actionable_comments_zero_pr_level(self, parser: GreptileParser) -> None:
        """Test PR-level summary with 'Actionable comments posted: 0' is NON_ACTIONABLE.

        Even though the existing parser returns NON_ACTIONABLE for this, we want to
        ensure PR-level summaries are consistently handled.
        """
        body = """<h3>Greptile Summary</h3>

Actionable comments posted: 0

3 files reviewed
"""
        comment = {"body": body, "path": None, "line": None}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert requires_investigation is False

    def test_pr_summary_actionable_comments_nonzero_pr_level(self, parser: GreptileParser) -> None:
        """Test PR-level summary with 'Actionable comments posted: N' is NON_ACTIONABLE.

        This is the key case - even when there ARE actionable comments, the summary
        itself should be NON_ACTIONABLE because the actual actionable items are
        in the inline comments.
        """
        body = """<h3>Greptile Summary</h3>

Actionable comments posted: 3

5 files reviewed

Edit Code Review Agent Settings
"""
        comment = {"body": body, "path": None, "line": None}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert requires_investigation is False

    def test_inline_comment_with_summary_pattern_not_filtered(self, parser: GreptileParser) -> None:
        """Test inline comment containing summary pattern is NOT filtered.

        Inline comments (with path/line) should never be filtered by summary detection,
        even if they happen to contain similar text patterns.
        """
        body = """The Greptile Summary mentioned 3 files reviewed but this
inline comment addresses the actual issue."""
        comment = {"body": body, "path": "src/file.py", "line": 42}
        classification, priority, requires_investigation = parser.parse(comment)

        # Should NOT be filtered - this is an inline comment
        # Without severity markers, it should be AMBIGUOUS
        assert classification == CommentClassification.AMBIGUOUS
        assert requires_investigation is True

    def test_inline_comment_with_severity_marker_not_filtered(self, parser: GreptileParser) -> None:
        """Test inline comment with severity marker is correctly classified.

        Inline comments should be classified by their severity markers,
        not filtered as summaries.
        """
        body = "**bug:** This function has a null pointer dereference."
        comment = {"body": body, "path": "src/file.py", "line": 42}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MAJOR
        assert requires_investigation is False

    def test_is_pr_summary_comment_returns_false_for_inline(self, parser: GreptileParser) -> None:
        """Test _is_pr_summary_comment returns False when path is set."""
        comment = {
            "body": "<h3>Greptile Summary</h3>\n\n3 files reviewed",
            "path": "src/file.py",
            "line": 10,
        }
        assert parser._is_pr_summary_comment(comment) is False

    def test_is_pr_summary_comment_returns_true_for_pr_level(self, parser: GreptileParser) -> None:
        """Test _is_pr_summary_comment returns True for PR-level summary."""
        comment = {
            "body": "<h3>Greptile Summary</h3>\n\n3 files reviewed",
            "path": None,
            "line": None,
        }
        assert parser._is_pr_summary_comment(comment) is True

    def test_is_pr_summary_comment_with_greptile_header(self, parser: GreptileParser) -> None:
        """Test _is_pr_summary_comment detects Greptile HTML header."""
        comment = {
            "body": "<h3>Greptile Summary</h3>",
            "path": None,
            "line": None,
        }
        assert parser._is_pr_summary_comment(comment) is True

    def test_is_pr_summary_comment_with_files_reviewed(self, parser: GreptileParser) -> None:
        """Test _is_pr_summary_comment detects 'files reviewed' pattern."""
        comment = {
            "body": "5 files reviewed, looks good",
            "path": None,
            "line": None,
        }
        assert parser._is_pr_summary_comment(comment) is True

    def test_is_pr_summary_comment_with_edit_settings(self, parser: GreptileParser) -> None:
        """Test _is_pr_summary_comment detects 'Edit Code Review Agent Settings'."""
        comment = {
            "body": "Review complete.\n\nEdit Code Review Agent Settings",
            "path": None,
            "line": None,
        }
        assert parser._is_pr_summary_comment(comment) is True

    def test_pr_summary_detection_case_insensitive(self, parser: GreptileParser) -> None:
        """Test that Greptile summary patterns are case-insensitive."""
        comment = {
            "body": "<H3>GREPTILE SUMMARY</H3>",
            "path": None,
            "line": None,
        }
        assert parser._is_pr_summary_comment(comment) is True
