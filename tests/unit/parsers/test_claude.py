"""Tests for Claude Code parser.

This module tests the ClaudeCodeParser implementation, verifying:
- Author and body detection patterns (can_parse)
- Actionable patterns (must, should fix, error, bug)
- Approval patterns (LGTM, looks good, approved, ship it)
- Suggestion patterns (consider, suggestion, might)
- Correct priority and requires_investigation values
"""

import pytest

from goodtogo.core.models import CommentClassification, Priority, ReviewerType
from goodtogo.parsers.claude import ClaudeCodeParser


class TestClaudeCodeParserCanParse:
    """Tests for ClaudeCodeParser.can_parse() method."""

    @pytest.fixture
    def parser(self) -> ClaudeCodeParser:
        """Create a ClaudeCodeParser instance."""
        return ClaudeCodeParser()

    def test_can_parse_by_author_claude_code_bot(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test detection by claude-code[bot] author."""
        assert parser.can_parse("claude-code[bot]", "") is True

    def test_can_parse_by_author_anthropic_claude_bot(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test detection by anthropic-claude[bot] author."""
        assert parser.can_parse("anthropic-claude[bot]", "") is True

    def test_can_parse_by_author_case_insensitive(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test that author matching is case-insensitive."""
        assert parser.can_parse("CLAUDE-CODE[BOT]", "") is True
        assert parser.can_parse("Claude-Code[bot]", "") is True
        assert parser.can_parse("ANTHROPIC-CLAUDE[bot]", "") is True

    def test_can_parse_by_body_generated_signature(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test detection by 'Generated with Claude Code' in body."""
        body = "Changes made.\n\nGenerated with Claude Code"
        assert parser.can_parse("other-user", body) is True

    def test_can_parse_by_body_claude_code_name(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test detection by 'Claude Code' in body."""
        body = "This review was performed by Claude Code."
        assert parser.can_parse("other-user", body) is True

    def test_can_parse_by_body_case_insensitive(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test that body signature detection is case-insensitive."""
        assert parser.can_parse("other", "GENERATED WITH CLAUDE CODE") is True
        assert parser.can_parse("other", "claude code") is True

    def test_can_parse_non_matching_author(self, parser: ClaudeCodeParser) -> None:
        """Test that non-matching authors are rejected."""
        assert parser.can_parse("random-user", "") is False
        assert parser.can_parse("github-bot", "") is False
        assert parser.can_parse("coderabbitai[bot]", "") is False
        assert parser.can_parse("", "") is False

    def test_can_parse_non_matching_body(self, parser: ClaudeCodeParser) -> None:
        """Test that non-matching bodies are rejected."""
        assert parser.can_parse("random-user", "Regular comment body") is False
        assert parser.can_parse("random-user", "Generated by some other tool") is False


class TestClaudeCodeParserReviewerType:
    """Tests for ClaudeCodeParser.reviewer_type property."""

    def test_reviewer_type_returns_claude(self) -> None:
        """Test that reviewer_type returns CLAUDE."""
        parser = ClaudeCodeParser()
        assert parser.reviewer_type == ReviewerType.CLAUDE


class TestClaudeCodeParserActionablePatterns:
    """Tests for actionable pattern detection."""

    @pytest.fixture
    def parser(self) -> ClaudeCodeParser:
        """Create a ClaudeCodeParser instance."""
        return ClaudeCodeParser()

    def test_parse_must_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'must' keyword triggers ACTIONABLE."""
        body = "You must handle this edge case."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR
        assert requires_investigation is False

    def test_parse_must_keyword_case_insensitive(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test 'must' keyword is case-insensitive."""
        body = "This MUST be fixed before merge."
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE

    def test_parse_must_as_word_boundary(self, parser: ClaudeCodeParser) -> None:
        """Test 'must' matches as whole word only."""
        body = "The mustard should be added to the config."
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        # 'mustard' should not match 'must'
        assert classification == CommentClassification.AMBIGUOUS

    def test_parse_should_fix_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'should fix' keyword triggers ACTIONABLE."""
        body = "You should fix this null pointer issue."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR
        assert requires_investigation is False

    def test_parse_error_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'error' keyword triggers ACTIONABLE."""
        body = "There is an error in the validation logic."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR
        assert requires_investigation is False

    def test_parse_error_as_word_boundary(self, parser: ClaudeCodeParser) -> None:
        """Test 'error' uses word boundary matching (\berror\b)."""
        # "errorHandler" does not contain standalone "error" due to \b word boundary
        # But "looks good" triggers NON_ACTIONABLE approval pattern
        body = "The errorHandler function looks good."
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        # "looks good" matches approval pattern -> NON_ACTIONABLE
        assert classification == CommentClassification.NON_ACTIONABLE

    def test_parse_bug_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'bug' keyword triggers ACTIONABLE."""
        body = "This is a bug that needs to be fixed."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR
        assert requires_investigation is False


class TestClaudeCodeParserApprovalPatterns:
    """Tests for approval/LGTM pattern detection."""

    @pytest.fixture
    def parser(self) -> ClaudeCodeParser:
        """Create a ClaudeCodeParser instance."""
        return ClaudeCodeParser()

    def test_parse_lgtm_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'LGTM' keyword triggers NON_ACTIONABLE."""
        body = "LGTM!"
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_parse_lgtm_case_insensitive(self, parser: ClaudeCodeParser) -> None:
        """Test 'lgtm' is case-insensitive."""
        body = "lgtm, ship it"
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE

    def test_parse_looks_good_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'looks good' keyword triggers NON_ACTIONABLE."""
        body = "This looks good to me."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_parse_approved_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'approved' keyword triggers NON_ACTIONABLE."""
        body = "Approved, ready to merge."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False

    def test_parse_approve_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'approve' keyword triggers NON_ACTIONABLE."""
        body = "I approve this change."
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE

    def test_parse_ship_it_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'ship it' keyword triggers NON_ACTIONABLE."""
        body = "Ship it!"
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.NON_ACTIONABLE
        assert priority == Priority.UNKNOWN
        assert requires_investigation is False


class TestClaudeCodeParserSuggestionPatterns:
    """Tests for suggestion/ambiguous pattern detection."""

    @pytest.fixture
    def parser(self) -> ClaudeCodeParser:
        """Create a ClaudeCodeParser instance."""
        return ClaudeCodeParser()

    def test_parse_consider_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'consider' keyword triggers AMBIGUOUS when no actionable keywords."""
        # Note: "error" in "error handling" would trigger ACTIONABLE first
        # Use a body without actionable keywords to test consider alone
        body = "Consider refactoring this method."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True

    def test_parse_consider_with_error_is_actionable(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test 'consider' is overridden by 'error' (actionable takes precedence)."""
        body = "Consider adding error handling here."
        comment = {"body": body}
        classification, priority, _ = parser.parse(comment)

        # "error" is an actionable keyword, checked before "consider"
        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR

    def test_parse_suggestion_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'suggestion' keyword triggers AMBIGUOUS."""
        body = "Here's a suggestion: use a context manager."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True

    def test_parse_might_keyword(self, parser: ClaudeCodeParser) -> None:
        """Test 'might' keyword triggers AMBIGUOUS."""
        body = "You might want to add a docstring here."
        comment = {"body": body}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True


class TestClaudeCodeParserPrecedence:
    """Tests for pattern precedence rules."""

    @pytest.fixture
    def parser(self) -> ClaudeCodeParser:
        """Create a ClaudeCodeParser instance."""
        return ClaudeCodeParser()

    def test_actionable_over_approval(self, parser: ClaudeCodeParser) -> None:
        """Test actionable patterns take precedence over approval."""
        body = "LGTM overall, but you must fix this null check."
        comment = {"body": body}
        classification, priority, _ = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR

    def test_actionable_over_suggestion(self, parser: ClaudeCodeParser) -> None:
        """Test actionable patterns take precedence over suggestions."""
        body = "Consider this, but you must also fix the error here."
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE

    def test_approval_over_suggestion(self, parser: ClaudeCodeParser) -> None:
        """Test approval patterns take precedence over suggestions."""
        body = "LGTM! You might consider adding a test later."
        comment = {"body": body}
        classification, _, requires_investigation = parser.parse(comment)

        # Note: Based on parser logic, actionable checked first, then approval
        # "might" is present but LGTM should win since it comes first in checks
        # Wait, "must" is checked before LGTM, and "might" is checked after LGTM
        # So LGTM should match first
        assert classification == CommentClassification.NON_ACTIONABLE
        assert requires_investigation is False


class TestClaudeCodeParserAmbiguous:
    """Tests for default ambiguous handling."""

    @pytest.fixture
    def parser(self) -> ClaudeCodeParser:
        """Create a ClaudeCodeParser instance."""
        return ClaudeCodeParser()

    def test_parse_empty_body(self, parser: ClaudeCodeParser) -> None:
        """Test empty body results in AMBIGUOUS."""
        comment = {"body": ""}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True

    def test_parse_missing_body(self, parser: ClaudeCodeParser) -> None:
        """Test missing body key results in AMBIGUOUS."""
        comment = {}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True

    def test_parse_unrecognized_pattern(self, parser: ClaudeCodeParser) -> None:
        """Test unrecognized body pattern results in AMBIGUOUS."""
        comment = {"body": "The implementation is interesting."}
        classification, priority, requires_investigation = parser.parse(comment)

        assert classification == CommentClassification.AMBIGUOUS
        assert priority == Priority.UNKNOWN
        assert requires_investigation is True


class TestClaudeCodeParserEdgeCases:
    """Tests for edge cases and special scenarios."""

    @pytest.fixture
    def parser(self) -> ClaudeCodeParser:
        """Create a ClaudeCodeParser instance."""
        return ClaudeCodeParser()

    def test_parse_multiple_actionable_keywords(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test body with multiple actionable keywords."""
        body = "There's an error here and a bug there."
        comment = {"body": body}
        classification, priority, _ = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
        assert priority == Priority.MINOR

    def test_parse_body_with_code_block(self, parser: ClaudeCodeParser) -> None:
        """Test body with code block - approval pattern wins over code content."""
        body = """
        ```python
        def must_validate():
            pass
        ```
        This looks good overall.
        """
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        # Parser uses \bmust\b word boundary, so "must_validate" doesn't match "must"
        # However, "looks good" matches approval pattern -> NON_ACTIONABLE
        assert classification == CommentClassification.NON_ACTIONABLE

    def test_parse_code_block_with_actionable_keyword(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test body with actual actionable keyword in code block."""
        body = """
        ```python
        # This must be validated
        def validate():
            pass
        ```
        """
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        # "must" as standalone word in comment triggers ACTIONABLE
        assert classification == CommentClassification.ACTIONABLE

    def test_parse_long_body_with_late_keyword(
        self, parser: ClaudeCodeParser
    ) -> None:
        """Test long body where keyword appears late."""
        body = """
        This is a comprehensive review of the changes.
        The code structure looks reasonable.
        The implementation follows best practices.
        However, you must add proper error handling.
        """
        comment = {"body": body}
        classification, _, _ = parser.parse(comment)

        assert classification == CommentClassification.ACTIONABLE
